/* Include necessary libraries */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Declaration of the lexer function generated by Flex */
#define YY_DECL int yylex()

/* Global counters */
int words = 0;
int chars = 0;
int lines = 1;
int column = 1;

/* Structure to define keywords and their descriptions */
typedef struct {
    char* keyword;
    char* description;
} Keyword;

/* Array of keywords */
Keyword keywords[] = {
    {"int", "TYPE"},
    {"char", "TYPE"},
    {"write", "KEYWORD"},
    {NULL, NULL} // End of array marker
};

/* Function to determine if a word is a keyword */
int is_keyword(const char* word) {
    for (int i = 0; keywords[i].keyword != NULL; i++) {
        if (strcmp(word, keywords[i].keyword) == 0)
            return i;
    }
    return -1; // Return -1 if not a keyword
}

/* Function to print token information */
void print_token(const char* text, const char* token_type) {
    printf("%s : %s at line %d, column %d\n", text, token_type, lines, column);
    column += strlen(text);
}

/* Define character sets */
letter      [a-zA-Z]
digit       [0-9]
ID          {letter}({letter}|{digit})*
delim       [ \t\n]
NUMBER      {digit}+(\.{digit}+)?(E[+\-]?{digit}+)?
ws          {delim}+

%%

/* Handling block comments */
"/*"        {
                    int c, last = 0;
                    while((c = input()) != 0) {
                        if(last == '*' && c == '/') break;
                        last = c;
                    }
                }

/* Handling identifiers and keywords */
{ID}        {
                    int kw_index = is_keyword(yytext);
                    if (kw_index != -1) {
                        print_token(yytext, keywords[kw_index].description);
                    } else {
                        print_token(yytext, "IDENTIFIER");
                    }
                    words++; chars += strlen(yytext);
                }

/* Handling numeric literals */
{NUMBER}    {
                    print_token(yytext, "NUMBER");
                    words++; chars += strlen(yytext);
                }

/* Handling semicolons */
";"         {
                    chars++;
                    print_token(";", "SEMICOLON");
                }

/* Handling assignment operator */
"="         {
                    chars++;
                    print_token("=", "ASSIGNMENT");
                }

/* Handling arithmetic operators */
"+"         {
              chars++;
              print_token("+", "ADDITION");
            }
"-"         {
              chars++;
              print_token("-", "SUBTRACTION");
            }
"*"         {
              chars++;
              print_token("*", "MULTIPLICATION");
            }
"/"         {
              chars++;
              print_token("/", "DIVISION");
            }

/* Handling newlines */
\n          {
                    lines++; chars = 0; column = 1;
                }

/* Handling whitespace */
[ \t]+      {
                    chars += strlen(yytext); column += strlen(yytext);
                }

/* Handling unrecognized characters */
.           {
                    chars++;
                    printf("Error: Unrecognized character '%c' at line %d, column %d\n", yytext[0], lines, column);
                    column++;
                }

%%
/* Main function to run the lexer */
int main(int argc, char**argv)
{
    #ifdef YYDEBUG
    yydebug = 1;
    #endif

    printf("Lexer started. \n\n");

    if (argc > 1) {
        if (!(yyin = fopen(argv[1], "r"))) {
            perror(argv[1]);
            return 1;
        }
    }
    yylex();
    if (yyin) fclose(yyin);
    return 0;
}
